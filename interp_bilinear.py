import numpy as np

def interp_bilinearR(R):
    row, col = R.shape
    #hor
    for i in range(row // 4):
        for j in range(col // 4 - 1):
            R[i * 4, j * 4 + 2] = (R[i * 4, j * 4 + 1] * 2 + R[i * 4, j * 4 + 4]) / 3
            R[i * 4, j * 4 + 3] = (R[i * 4, j * 4 + 4] * 2 + R[i * 4, j * 4 + 1]) / 3
            R[i * 4 + 1, j * 4 + 2] = (R[i * 4 + 1, j * 4 + 1] * 2 + R[i * 4 + 1, j * 4 + 4]) / 3
            R[i * 4 + 1, j * 4 + 3] = (R[i * 4 + 1, j * 4 + 4] * 2 + R[i * 4 + 1, j * 4 + 1]) / 3
    #ver
    for i in range(row // 4 - 1):
        for j in range(col // 4):
            R[i * 4 + 2, j * 4] = (R[i * 4 + 1, j * 4] * 2 + R[i * 4 + 4, j * 4]) / 3
            R[i * 4 + 3, j * 4] = (R[i * 4 + 4, j * 4] * 2 + R[i * 4 + 1, j * 4]) / 3
            R[i * 4 + 2, j * 4 + 1] = (R[i * 4 + 1, j * 4 + 1] * 2 + R[i * 4 + 4, j * 4 + 1]) / 3
            R[i * 4 + 3, j * 4 + 1] = (R[i * 4 + 4, j * 4 + 1] * 2 + R[i * 4 + 1, j * 4 + 1]) / 3
    #center
    for i in range(row // 4 - 1):
        for j in range(col // 4 - 1):
            R[i * 4 + 2, j * 4 + 2] = (R[i * 4 + 1, j * 4 + 1] * 4 +
                                       R[i * 4 + 1, j * 4 + 4] * 2 +
                                       R[i * 4 + 4, j * 4 + 1] * 2 +
                                       R[i * 4 + 4, j * 4 + 4]) / 9
            R[i * 4 + 2, j * 4 + 3] = (R[i * 4 + 1, j * 4 + 4] * 4 +
                                       R[i * 4 + 1, j * 4 + 1] * 2 +
                                       R[i * 4 + 4, j * 4 + 4] * 2 +
                                       R[i * 4 + 4, j * 4 + 1]) / 9
            R[i * 4 + 3, j * 4 + 2] = (R[i * 4 + 4, j * 4 + 1] * 4 +
                                       R[i * 4 + 1, j * 4 + 1] * 2 +
                                       R[i * 4 + 4, j * 4 + 4] * 2 +
                                       R[i * 4 + 1, j * 4 + 4]) / 9
            R[i * 4 + 3, j * 4 + 3] = (R[i * 4 + 4, j * 4 + 4] * 4 +
                                       R[i * 4 + 1, j * 4 + 4] * 2 +
                                       R[i * 4 + 4, j * 4 + 1] * 2 +
                                       R[i * 4 + 1, j * 4 + 1]) / 9
    # edge
    R[:, col - 1] = R[:, col - 3]
    R[:, col - 2] = R[:, col - 3]
    R[row - 1, :] = R[row - 3, :]
    R[row - 2, :] = R[row - 3, :]
    return R

def interp_bilinearB(B):
    row, col = B.shape
    #hor
    for i in range(row // 4):
        for j in range(1, col // 4):
            B[i * 4 + 2, j * 4] = (B[i * 4 + 2, j * 4 - 1] * 2 + B[i * 4 + 2, j * 4 + 2]) / 3
            B[i * 4 + 2, j * 4 + 1] = (B[i * 4 + 2, j * 4 + 2] * 2 + B[i * 4 + 2, j * 4 - 1]) / 3
            B[i * 4 + 3, j * 4] = (B[i * 4 + 3, j * 4 - 1] * 2 + B[i * 4 + 3, j * 4 + 2]) / 3
            B[i * 4 + 3, j * 4 + 1] = (B[i * 4 + 3, j * 4 + 2] * 2 + B[i * 4 + 3, j * 4 - 1]) / 3
    #ver
    for i in range(1, row // 4):
        for j in range(col // 4):
            B[i * 4, j * 4 + 2] = (B[i * 4 - 1, j * 4 + 2] * 2 + B[i * 4 + 2, j * 4 + 2]) / 3
            B[i * 4 + 1, j * 4 + 2] = (B[i * 4 + 2, j * 4 + 2] * 2 + B[i * 4 - 1, j * 4 + 2]) / 3
            B[i * 4, j * 4 + 3] = (B[i * 4 - 1, j * 4 + 3] * 2 + B[i * 4 + 2, j * 4 + 3]) / 3
            B[i * 4 + 1, j * 4 + 3] = (B[i * 4 + 2, j * 4 + 3] * 2 + B[i * 4 - 1, j * 4 + 3]) / 3
    #center
    for i in range(1, row // 4):
        for j in range(1, col // 4):
            B[i * 4, j * 4] = (B[i * 4 - 1, j * 4 - 1] * 4 +
                               B[i * 4 - 1, j * 4 + 2] * 2 +
                               B[i * 4 + 2, j * 4 - 1] * 2 +
                               B[i * 4 + 2, j * 4 + 2]) / 9
            B[i * 4, j * 4 + 1] = (B[i * 4 - 1, j * 4 + 2] * 4 +
                                   B[i * 4 - 1, j * 4 - 1] * 2 +
                                   B[i * 4 + 2, j * 4 + 2] * 2 +
                                   B[i * 4 - 1, j * 4 - 1]) / 9
            B[i * 4 + 1, j * 4] = (B[i * 4 + 2, j * 4 - 1] * 4 +
                                   B[i * 4 - 1, j * 4 + 2] * 2 +
                                   B[i * 4 + 2, j * 4 + 2] * 2 +
                                   B[i * 4 - 1, j * 4 + 2]) / 9
            B[i * 4 + 1, j * 4 + 1] = (B[i * 4 + 2, j * 4 + 2] * 4 +
                                       B[i * 4 - 1, j * 4 + 2] * 2 +
                                       B[i * 4 + 2, j * 4 - 1] * 2 +
                                       B[i * 4 - 1, j * 4 - 1]) / 9
    # edge
    B[:, 0] = B[:, 2]
    B[:, 1] = B[:, 2]
    B[0, :] = B[2, :]
    B[1, :] = B[2, :]
    return B

def interp_bilinearG(G):
    row, col = G.shape

    #case1
    for i in range(row // 4 - 1):
        for j in range(col // 4 - 1):
            G[i * 4 + 2, j * 4 + 2] = (G[i * 4 + 1, j * 4 + 2] * 2 +
                                       G[i * 4 + 2, j * 4 + 1] * 2 +
                                       G[i * 4 + 2, j * 4 + 4] +
                                       G[i * 4 + 4, j * 4 + 2]) / 6
            G[i * 4 + 2, j * 4 + 3] = (G[i * 4 + 1, j * 4 + 3] * 2 +
                                       G[i * 4 + 2, j * 4 + 4] * 2 +
                                       G[i * 4 + 2, j * 4 + 1] +
                                       G[i * 4 + 4, j * 4 + 3]) / 6
            G[i * 4 + 3, j * 4 + 2] = (G[i * 4 + 3, j * 4 + 1] * 2 +
                                       G[i * 4 + 4, j * 4 + 2] * 2 +
                                       G[i * 4 + 1, j * 4 + 2] +
                                       G[i * 4 + 3, j * 4 + 4]) / 6
            G[i * 4 + 3, j * 4 + 3] = (G[i * 4 + 3, j * 4 + 4] * 2 +
                                       G[i * 4 + 4, j * 4 + 3] * 2 +
                                       G[i * 4 + 1, j * 4 + 3] +
                                       G[i * 4 + 3, j * 4 + 1]) / 6
    i = row // 4 - 1
    for j in range(col // 4 - 1):
        G[i * 4 + 2, j * 4 + 2] = (G[i * 4 + 2, j * 4 + 1] * 2 + G[i * 4 + 2, j * 4 + 4]) / 3
        G[i * 4 + 2, j * 4 + 3] = (G[i * 4 + 2, j * 4 + 4] * 2 + G[i * 4 + 2, j * 4 + 1]) / 3
        G[i * 4 + 2 + 1, j * 4 + 2] = (G[i * 4 + 2 + 1, j * 4 + 1] * 2 + G[i * 4 + 2 + 1, j * 4 + 4]) / 3
        G[i * 4 + 2 + 1, j * 4 + 3] = (G[i * 4 + 2 + 1, j * 4 + 4] * 2 + G[i * 4 + 2 + 1, j * 4 + 1]) / 3

    j = col // 4 - 1
    for i in range(row // 4 - 1):
        G[i * 4 + 2, j * 4 + 2] = (G[i * 4 + 1, j * 4 + 2] * 2 + G[i * 4 + 4, j * 4 + 2]) / 3
        G[i * 4 + 3, j * 4 + 2] = (G[i * 4 + 4, j * 4 + 2] * 2 + G[i * 4 + 1, j * 4 + 2]) / 3
        G[i * 4 + 2, j * 4 + 2 + 1] = (G[i * 4 + 1, j * 4 + 2 + 1] * 2 + G[i * 4 + 4, j * 4 + 2 + 1]) / 3
        G[i * 4 + 3, j * 4 + 2 + 1] = (G[i * 4 + 4, j * 4 + 2 + 1] * 2 + G[i * 4 + 1, j * 4 + 2 + 1]) / 3

    G[row - 2, col - 2] = (G[row - 2, col - 3] + G[row - 3, col - 2]) / 2
    G[row - 2, col - 1] = G[row - 3, col - 1]
    G[row - 1, col - 2] = G[row - 1, col - 3]
    G[row - 1, col - 1] = (G[row - 3, col - 1] + G[row - 1, col - 3]) / 2

    #case2
    for i in range(1, row // 4):
        for j in range(1, col // 4):
            G[i * 4, j * 4] = (G[i * 4 - 1, j * 4] * 2 +
                               G[i * 4, j * 4 - 1] * 2 +
                               G[i * 4, j * 4 + 2] +
                               G[i * 4 + 2, j * 4]) / 6
            G[i * 4, j * 4 + 1] = (G[i * 4 - 1, j * 4 + 1] * 2 +
                                   G[i * 4, j * 4 + 2] * 2 +
                                   G[i * 4, j * 4 - 1] +
                                   G[i * 4 + 2, j * 4 + 1]) / 6
            G[i * 4 + 1, j * 4] = (G[i * 4 + 1, j * 4 - 1] * 2 +
                                   G[i * 4 + 2, j * 4] * 2 +
                                   G[i * 4 - 1, j * 4] +
                                   G[i * 4 + 1, j * 4 + 2]) / 6
            G[i * 4 + 1, j * 4 + 1] = (G[i * 4 + 1, j * 4 + 2] * 2 +
                                       G[i * 4 + 2, j * 4 + 1] * 2 +
                                       G[i * 4 - 1, j * 4 + 1] +
                                       G[i * 4 + 1, j * 4 - 1]) / 6

    i = 0
    for j in range(1, col // 4):
        G[i * 4, j * 4] = (G[i * 4, j * 4 - 1] * 2 + G[i * 4, j * 4 + 2]) / 3
        G[i * 4, j * 4 + 1] = (G[i * 4, j * 4 + 2] * 2 + G[i * 4, j * 4 - 1]) / 3
        G[i * 4 + 1, j * 4] = (G[i * 4 + 1, j * 4 - 1] * 2 + G[i * 4 + 1, j * 4 + 2]) / 3
        G[i * 4 + 1, j * 4 + 1] = (G[i * 4 + 1, j * 4 + 2] * 2 + G[i * 4 + 1, j * 4 - 1]) / 3

    j = 0
    for i in range(1, row // 4):
        G[i * 4, j * 4] = (G[i * 4 - 1, j * 4] * 2 + G[i * 4 + 2, j * 4]) / 3
        G[i * 4 + 1, j * 4] = (G[i * 4 + 2, j * 4] * 2 + G[i * 4 - 1, j * 4]) / 3
        G[i * 4, j * 4 + 1] = (G[i * 4 - 1, j * 4 + 1] * 2 + G[i * 4 + 2, j * 4 + 1]) / 3
        G[i * 4 + 1, j * 4 + 1] = (G[i * 4 + 2, j * 4 + 1] * 2 + G[i * 4 - 1, j * 4 + 1]) / 3

    G[0, 0] = (G[0, 2] + G[2, 0]) / 2
    G[0, 1] = G[0, 2]
    G[1, 0] = G[2, 0]
    G[1, 1] = (G[1, 2] + G[2, 1]) / 2

    return G